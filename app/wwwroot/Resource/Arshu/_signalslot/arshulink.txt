
https://github.com/jaz303/trigger.js

© 2010 Jason Frame [ jason@onehackoranother.com / @jaz303 ]
Released under the MIT License.


Events

In order for your handler functions to be called, they must first be registered. Registration functions come in a number of flavours:

1) Event name	link.observeEvent(eventPattern, callback)	

Watch for all events whose name matches the supplied pattern. 
Event names are simply namespaced strings using `.` as a separator. Wildcards are supported:
? matches a single component e.g.  foo.? matches foo.bar and foo.baz but does not match foo nor foo.bar.baz.
* matches one or more components e.g. foo.* matches foo.bar, foo.baz and foo.bar.baz does not match foo.

2) Source object identity	link.observeObject(source, callback)	

Watch for all events generated by a single object. Equality test is performed using ==

3) Source object type	link.observeType(sourceType, callback)	

Watch for all events generated by objects of a given type. Type check is performed using instanceof

There's also a generic registration method, trigger.registerEventHandler(sourceType, source, eventPattern, callback), 
if you need to watch for a combination of the above. Like all update events for instances of FooWidget. Pass null for any conditions you're not interested in.

Once you've registered your handlers (or even before...) you can start firing events about. It's pretty simple:

trigger.fire(this, 'auction.expired', {auction_id: 123425});

The final parameter, user info, is optional and defaults to an empty object. Events are fired synchronously.

Filters

A named filter in arshulink.js is a chain of event handlers, each of which returns a value. The result of each filter is passed back into the next filter, with the final value ultimately being returned to the caller. Example:

trigger.registerFilter('myFilter', function(s) { return s.toUpperCase(); });
trigger.registerFilter('myFilter', function(s) { return 'hello ' + s; });

// displays "hello JASON"
alert(trigger.filter('myFilter', 'jason'));

Filter names actually support wildcards too, but that doesn't really sound very useful.


Mixin' In

Calling trigger.fire(this, 'foo.bar', { ... }) sure gets tiresome. 

Use Trigger.mixin(object [, triggerRegistry]) to extend arbitrary objects with their own fire()/filter() methods, within which the implied event source is this. 

The optional second parameter, triggerRegistry allows you to specify an alternate trigger registry if you're not using the default window.trigger. FGJ:

var myArray = [];
Trigger.mixin(myArray);
myArray.fire("foo.blam", { ... });
var result = myArray.filter("send.prefilter", { ... });

Other Possibly Interesting Stuff

When an event handler or filter is registered you get back a Rule object. This has enable() and disable() methods for selectively toggling handlers without affecting other handlers in the chain.

By default, you get a single trigger registry, window.trigger. This is just an instance of Trigger so just create as many as you need.