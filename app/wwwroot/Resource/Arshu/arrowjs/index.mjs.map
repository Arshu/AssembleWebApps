{"version":3,"file":"index.mjs","sources":["../src/common.ts","../src/reactive.ts","../src/html.ts","../src/index.ts"],"sourcesContent":["/**\n * A queue of expressions to run as soon as an async slot opens up.\n */\nconst queueStack = new Set();\n/**\n * A stack of functions to run on the next tick.\n */\nconst nextTicks = new Set();\n/**\n * Adds the ability to listen to the next tick.\n * @param  {CallableFunction} fn?\n * @returns Promise\n */\nexport function nextTick(fn) {\n    if (!queueStack.size) {\n        if (fn)\n            fn();\n        return Promise.resolve();\n    }\n    let resolve;\n    const p = new Promise((r) => {\n        resolve = r;\n    });\n    nextTicks.add(() => {\n        if (fn)\n            fn();\n        resolve();\n    });\n    return p;\n}\nexport function isTpl(template) {\n    return typeof template === 'function' && !!template.isT;\n}\nexport function isR(obj) {\n    return (typeof obj === 'object' &&\n        obj !== null &&\n        '$on' in obj &&\n        typeof obj.$on === 'function');\n}\n/**\n * Utility that ensures we only attempt to make reactive objects that _can_ be made reactive.\n *\n * Examples of objects that cause issues: NodeList, HTMLElement\n * @see {@link https://github.com/vuejs/core/blob/8998afa42755cbdb3403cd6c0fe158980da8492c/packages/reactivity/src/reactive.ts#L43-L62}\n */\n// export function canReactiveWrap(maybeObj: any): boolean {\n//   return ['Object', 'Array'].includes(\n//     // from https://github.com/vuejs/core/blob/8998afa42755cbdb3403cd6c0fe158980da8492c/packages/shared/src/general.ts#L64-L67\n//     // extracts \"Type\" from \"[object Type]\"\n//     Object.prototype.toString.call(maybeObj).slice(8, -1)\n//   )\n// }\nexport function isReactiveFunction(fn) {\n    return '$on' in fn;\n}\n/**\n * Queue an item to execute after all synchronous functions have been run. This\n * is used for `w()` to ensure multiple dependency mutations tracked on the\n * same expression do not result in multiple calls.\n * @param  {CallableFunction} fn\n * @returns ObserverCallback\n */\nexport function queue(fn) {\n    return (newValue, oldValue) => {\n        function executeQueue() {\n            // copy the current queues and clear it to allow new items to be added\n            // during the execution of the current queue.\n            const queue = Array.from(queueStack);\n            queueStack.clear();\n            const ticks = Array.from(nextTicks);\n            nextTicks.clear();\n            queue.forEach((fn) => fn(newValue, oldValue));\n            ticks.forEach((fn) => fn());\n            if (queueStack.size) {\n                // we received new items while executing the queue, so we need to\n                // execute the queue again.\n                queueMicrotask(executeQueue);\n            }\n        }\n        if (!queueStack.size) {\n            queueMicrotask(executeQueue);\n        }\n        queueStack.add(fn);\n    };\n}\nexport const measurements = {};\n/**\n * A simple benchmarking function.\n * @param label - A label for the measurement\n * @param fn - A function to measure or a number to record\n * @returns\n */\nexport function measure(label, fn) {\n    const start = performance.now();\n    const isFn = typeof fn === 'function';\n    label = isFn ? `${label} (ms)` : `${label} (calls)`;\n    const x = isFn ? fn() : fn;\n    const result = isFn ? performance.now() - start : fn;\n    if (!measurements[label])\n        measurements[label] = [result];\n    else\n        measurements[label].push(result);\n    return x;\n}\n","import { isR, queue, isReactiveFunction } from './common';\n/**\n * A \"global\" dependency tracker object.\n */\nconst dependencyCollector = new Map();\n/**\n * Given a data object, often an object literal, return a proxy of that object\n * with mutation observers for each property.\n *\n * @param  {DataSource} data\n * @returns ReactiveProxy\n */\nexport function r(data, state = {}) {\n    // If this is already reactive, a non object, or an object than shouldn't be made reactive just return it.\n    if (isR(data) || typeof data !== 'object')\n        return data;\n    // This is the observer registry itself, with properties as keys and callbacks as watchers.\n    const observers = state.o || new Map();\n    // This is a reverse map of observers with callbacks as keys and properties that callback is watching as values.\n    const observerProperties = state.op || new Map();\n    // If the data is an array, we should know...but only once.\n    const isArray = Array.isArray(data);\n    const children = [];\n    const proxySource = isArray ? [] : Object.create(data, {});\n    for (const property in data) {\n        const entry = data[property];\n        if (typeof entry === 'object' && entry !== null) {\n            proxySource[property] = !isR(entry) ? r(entry) : entry;\n            children.push(property);\n        }\n        else {\n            proxySource[property] = entry;\n        }\n    }\n    // The add/remove dependency function(s)\n    const dep = (a) => (p, c) => {\n        let obs = observers.get(p);\n        let props = observerProperties.get(c);\n        if (!obs) {\n            obs = new Set();\n            observers.set(p, obs);\n        }\n        if (!props) {\n            props = new Set();\n            observerProperties.set(c, props);\n        }\n        obs[a](c);\n        props[a](p);\n    };\n    // Add a property listener\n    const $on = dep('add');\n    // Remove a property listener\n    const $off = dep('delete');\n    // Emit a property mutation event by calling all sub-dependencies.\n    const _em = (property, newValue, oldValue) => {\n        observers.has(property) &&\n            observers.get(property).forEach((c) => c(newValue, oldValue));\n    };\n    /**\n     * Return the reactive proxy state data.\n     */\n    const _st = () => {\n        return {\n            o: observers,\n            op: observerProperties,\n            r: proxySource,\n            p: proxy._p,\n        };\n    };\n    // These are the internal properties of all `r()` objects.\n    const depProps = {\n        $on,\n        $off,\n        _em,\n        _st,\n        _p: undefined,\n    };\n    // Create the actual proxy object itself.\n    const proxy = new Proxy(proxySource, {\n        has(target, key) {\n            return key in depProps || key in target;\n        },\n        get(...args) {\n            const [, p] = args;\n            // For properties of the DependencyProps type, return their values from\n            // the depProps instead of the target.\n            if (Reflect.has(depProps, p))\n                return Reflect.get(depProps, p);\n            const value = Reflect.get(...args);\n            // For any existing dependency collectors that are active, add this\n            // property to their observed properties.\n            addDep(proxy, p);\n            // We have special handling of array operations to prevent O(n^2) issues.\n            if (isArray && p in Array.prototype) {\n                return arrayOperation(p, proxySource, proxy, value);\n            }\n            return value;\n        },\n        set(...args) {\n            const [target, property, value] = args;\n            const old = Reflect.get(target, property);\n            if (Reflect.has(depProps, property)) {\n                // We are setting a reserved property like _p\n                return Reflect.set(depProps, property, value);\n            }\n            if (value && isR(old)) {\n                const o = old;\n                // We're assigning an object (array or pojo probably), so we want to be\n                // reactive, but if we already have a reactive object in this\n                // property, then we need to replace it and transfer the state of deps.\n                const oldState = o._st();\n                const newR = isR(value) ? reactiveMerge(value, o) : r(value, oldState);\n                Reflect.set(target, property, \n                // Create a new reactive object\n                newR);\n                _em(property, newR);\n                oldState.o.forEach((_c, property) => {\n                    const oldValue = Reflect.get(old, property);\n                    const newValue = Reflect.get(newR, property);\n                    if (oldValue !== newValue) {\n                        o._em(property, newValue, oldValue);\n                    }\n                });\n                return true;\n            }\n            const didSet = Reflect.set(...args);\n            if (didSet) {\n                if (old !== value) {\n                    // Notify any discrete property observers of the change.\n                    _em(property, value, old);\n                }\n                if (proxy._p) {\n                    // Notify parent observers of a change.\n                    proxy._p[1]._em(...proxy._p);\n                }\n            }\n            return didSet;\n        },\n    });\n    if (state.p)\n        proxy._p = state.p;\n    // Before we return the proxy object, quickly map through the children\n    // and set the parents (this is only run on the initial setup).\n    children.map((c) => {\n        proxy[c]._p = [c, proxy];\n    });\n    return proxy;\n}\n/**\n * Add a property to the tracked reactive properties.\n * @param  {ReactiveProxy} proxy\n * @param  {DataSourceKey} property\n */\nfunction addDep(proxy, property) {\n    dependencyCollector.forEach((tracker) => {\n        let properties = tracker.get(proxy);\n        if (!properties) {\n            properties = new Set();\n            tracker.set(proxy, properties);\n        }\n        properties.add(property);\n    });\n}\nfunction arrayOperation(op, arr, proxy, native) {\n    const synthetic = (...args) => {\n        // The `as DataSource` here should really be the ArrayPrototype, but we're\n        // just tricking the compiler since we've already checked it.\n        const retVal = Array.prototype[op].call(arr, ...args);\n        // @todo determine how to handle notifying elements and parents of elements.\n        arr.forEach((item, i) => proxy._em(String(i), item));\n        // Notify the the parent of changes.\n        if (proxy._p) {\n            const [property, parent] = proxy._p;\n            parent._em(property, proxy);\n        }\n        return retVal;\n    };\n    switch (op) {\n        case 'shift':\n        case 'pop':\n        case 'sort':\n        case 'reverse':\n        case 'copyWithin':\n            return synthetic;\n        case 'unshift':\n        case 'push':\n        case 'fill':\n            return (...args) => synthetic(...args.map((arg) => r(arg)));\n        case 'splice':\n            return function (start, remove, ...inserts) {\n                // Preserve the argument count when there's only one argument,\n                // because if a second argument is passed but undefined,\n                // it gets treated as 0.\n                return arguments.length === 1\n                    ? synthetic(start)\n                    : synthetic(start, remove, ...inserts.map((arg) => r(arg)));\n            };\n        default:\n            return native;\n    }\n}\n/**\n * Given two reactive proxies, merge the important state attributes from the\n * source into the target.\n * @param  {ReactiveProxy} reactiveTarget\n * @param  {ReactiveProxy} reactiveSource\n * @returns ReactiveProxy\n */\nfunction reactiveMerge(reactiveTarget, reactiveSource) {\n    const state = reactiveSource._st();\n    if (state.o) {\n        state.o.forEach((callbacks, property) => {\n            callbacks.forEach((c) => {\n                reactiveTarget.$on(property, c);\n            });\n        });\n    }\n    if (state.p) {\n        reactiveTarget._p = state.p;\n    }\n    return reactiveTarget;\n}\n/**\n * Watch a function and track any reactive dependencies on it, re-calling it if\n * those dependencies are changed.\n * @param  {CallableFunction} fn\n * @param  {CallableFunction} after?\n * @returns unknown\n */\nexport function w(fn, after) {\n    const trackingId = Symbol();\n    if (!dependencyCollector.has(trackingId)) {\n        dependencyCollector.set(trackingId, new Map());\n    }\n    let currentDeps = new Map();\n    const queuedCallFn = queue(callFn);\n    function callFn() {\n        dependencyCollector.set(trackingId, new Map());\n        const value = fn();\n        const newDeps = dependencyCollector.get(trackingId);\n        dependencyCollector.delete(trackingId);\n        // Disable existing properties\n        currentDeps.forEach((propertiesToUnobserve, proxy) => {\n            const newProperties = newDeps.get(proxy);\n            if (newProperties) {\n                newProperties.forEach((prop) => propertiesToUnobserve.delete(prop));\n            }\n            propertiesToUnobserve.forEach((prop) => proxy.$off(prop, queuedCallFn));\n        });\n        // Start observing new properties.\n        newDeps.forEach((properties, proxy) => {\n            properties.forEach((prop) => proxy.$on(prop, queuedCallFn));\n        });\n        currentDeps = newDeps;\n        return after ? after(value) : value;\n    }\n    // If this is a reactive function, then when the expression is updated, re-run\n    if (isReactiveFunction(fn))\n        fn.$on(callFn);\n    return callFn();\n}\n","import { w } from './reactive';\nimport { isTpl, measure } from './common';\n/**\n * Event listeners that were bound by arrow and should be cleaned up should the\n * given node be garbage collected.\n */\nconst listeners = new WeakMap();\n/**\n * A list of HTML templates to a HTMLTemplate element that contains instances\n * of each. This acts as a cache.\n */\nconst templateMemo = {};\n/**\n * The delimiter that describes where expressions are located.\n */\nconst delimiter = '➳❍';\nconst bookend = '❍⇚';\nconst delimiterComment = `<!--${delimiter}-->`;\nconst bookendComment = `<!--${bookend}-->`;\n/**\n * The template tagging function, used like: html`<div></div>`(mountEl)\n * @param  {TemplateStringsArray} strings\n * @param  {any[]} ...expressions\n * @returns ArrowTemplate\n */\nexport function t(strings, ...expSlots) {\n    const expressions = [];\n    let str = '';\n    const addExpressions = (expression, html) => {\n        if (typeof expression === 'function') {\n            // eslint-disable-next-line @typescript-eslint/no-empty-function\n            let observer = () => { };\n            expressions.push(Object.assign((...args) => expression(...args), {\n                e: expression,\n                $on: (obs) => {\n                    observer = obs;\n                },\n                _up: (exp) => {\n                    expression = exp;\n                    observer();\n                },\n            }));\n            return html + delimiterComment;\n        }\n        if (Array.isArray(expression)) {\n            return expression.reduce((html, exp) => addExpressions(exp, html), html);\n        }\n        return html + expression;\n    };\n    const toString = () => {\n        if (!str) {\n            if (!expSlots.length && strings.length === 1 && strings[0] === '') {\n                str = '<!---->';\n            }\n            else {\n                str = strings.reduce(function interlaceTemplate(html, strVal, i) {\n                    html += strVal;\n                    return expSlots[i] !== undefined\n                        ? addExpressions(expSlots[i], html)\n                        : html;\n                }, '');\n            }\n        }\n        return str;\n    };\n    const template = (el) => {\n        const dom = createNodes(toString());\n        const frag = fragment(dom, { i: 0, e: expressions });\n        return el ? frag(el) : frag();\n    };\n    // If the template contains no expressions, it is 100% static so it's key\n    // its own content\n    template.isT = true;\n    template._k = 0;\n    template._h = () => [toString(), expressions, template._k];\n    template.key = (key) => {\n        template._k = key;\n        return template;\n    };\n    return template;\n}\n/**\n * @param  {NodeList} dom\n * @param  {ReactiveExpressions} tokens\n * @param  {ReactiveProxy} data?\n */\nfunction fragment(dom, expressions) {\n    let node;\n    let i = 0;\n    const children = dom.childNodes;\n    while ((node = children.item(i++))) {\n        // Delimiters in the body are found inside comments.\n        if (node.nodeType === 8 && node.nodeValue === delimiter) {\n            // We are dealing with a reactive node.\n            comment(node, expressions);\n            continue;\n        }\n        // Bind attributes, add events, and push onto the fragment.\n        if (node instanceof Element)\n            attrs(node, expressions);\n        if (node.hasChildNodes()) {\n            fragment(node, expressions);\n        }\n        // Select lists \"default\" selections get out of wack when being moved around\n        // inside fragments, this resets them.\n        if (node instanceof HTMLOptionElement)\n            node.selected = node.defaultSelected;\n    }\n    return ((parent) => {\n        if (parent) {\n            parent.appendChild(dom);\n            return parent;\n        }\n        return dom;\n    });\n}\n/**\n * Given a node, parse for meaningful expressions.\n * @param  {Element} node\n * @returns void\n */\nfunction attrs(node, expressions) {\n    var _a;\n    const toRemove = [];\n    let i = 0;\n    let attr;\n    while ((attr = node.attributes[i++])) {\n        if (expressions.i >= expressions.e.length)\n            return;\n        if (attr.value !== delimiterComment)\n            continue;\n        let attrName = attr.name;\n        const expression = expressions.e[expressions.i++];\n        if (attrName.charAt(0) === '@') {\n            const event = attrName.substring(1);\n            node.addEventListener(event, expression);\n            if (!listeners.has(node))\n                listeners.set(node, new Map());\n            (_a = listeners.get(node)) === null || _a === void 0 ? void 0 : _a.set(event, expression);\n            toRemove.push(attrName);\n        }\n        else {\n            // Logic to determine if this is an IDL attribute or a content attribute\n            const isIDL = (attrName === 'value' && 'value' in node) ||\n                attrName === 'checked' ||\n                (attrName.startsWith('.') && (attrName = attrName.substring(1)));\n            w(expression, (value) => {\n                if (isIDL) {\n                    // Handle all IDL attributes, TS won’t like this since it is not\n                    // fully aware of the type we are operating on, but JavaScript is\n                    // perfectly fine with it, so we need to ignore TS here.\n                    // @ts-ignore:next-line\n                    node[attrName] = value;\n                    // Explicitly set the \"value\" to false remove the attribute. However\n                    // we need to be sure this is not a \"Reflected\" attribute, so we check\n                    // the current value of the attribute to make sure it is not the same\n                    // as the value we just set. If it is the same, it must be reflected.\n                    // so removing the attribute would remove the idl we just set.\n                    if (node.getAttribute(attrName) != value)\n                        value = false;\n                }\n                // Set a standard content attribute.\n                value !== false\n                    ? node.setAttribute(attrName, value)\n                    : (node.removeAttribute(attrName), i--);\n            });\n        }\n    }\n    toRemove.forEach((attrName) => node.removeAttribute(attrName));\n}\n/**\n * Removes DOM nodes from the dom and cleans up any attached listeners.\n * @param node - A DOM element to remove\n */\nfunction removeNodes(node) {\n    node.forEach(removeNode);\n}\n/**\n * Removes the node from the dom and cleans up any attached listeners.\n * @param node - A DOM element to remove\n */\nfunction removeNode(node) {\n    var _a;\n    node.remove();\n    (_a = listeners\n        .get(node)) === null || _a === void 0 ? void 0 : _a.forEach((listener, event) => node.removeEventListener(event, listener));\n}\n/**\n * Given a textNode, parse the node for expressions and return a fragment.\n * @param  {Node} node\n * @param  {ReactiveProxy} data\n * @param  {ReactiveExpressions} tokens\n * @returns DocumentFragment\n */\nfunction comment(node, expressions) {\n    var _a;\n    // At this point, we know we're dealing with some kind of reactive token fn\n    const expression = expressions.e[expressions.i++];\n    let boundNode;\n    if (expression && isTpl(expression.e)) {\n        // If the expression is an html`` (ArrowTemplate), then call it with data\n        // and then call the ArrowTemplate with no parent, so we get the nodes.\n        boundNode = createPartial().add(expression.e)();\n    }\n    else {\n        // This is where the *actual* reactivity takes place:\n        let partialMemo;\n        boundNode = (partialMemo = w(expression, (value) => setNode(value, partialMemo)))();\n    }\n    (_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.replaceChild(boundNode, node);\n}\n/**\n * Set the value of a given node.\n * @param  {Node} n\n * @param  {any} value\n * @param  {ReactiveProxy} data\n * @returns Node\n */\nfunction setNode(value, p) {\n    const isUpdate = typeof p === 'function';\n    const partial = isUpdate ? p : createPartial();\n    Array.isArray(value)\n        ? value.forEach((item) => measure('partialAdd', () => partial.add(item)))\n        : partial.add(value);\n    if (isUpdate)\n        partial._up();\n    return partial;\n}\n/**\n * Given an HTML string, produce actual DOM elements.\n * @param html - a string of html\n * @returns\n */\nfunction createNodes(html) {\n    var _a;\n    const tpl = (_a = templateMemo[html]) !== null && _a !== void 0 ? _a : (() => {\n        const tpl = document.createElement('template');\n        tpl.innerHTML = html;\n        return (templateMemo[html] = tpl);\n    })();\n    const dom = tpl.content.cloneNode(true);\n    dom.normalize(); // textNodes are automatically split somewhere around 65kb, this joins them back together.\n    return dom;\n}\n/**\n * Template partials are stateful functions that perform a fragment render when\n * called, but also have function properties like ._up() which attempts to only\n * perform a patch of the previously rendered nodes.\n * @returns TemplatePartial\n */\nfunction createPartial(group = Symbol()) {\n    let html = '';\n    let expressions = { i: 0, e: [] };\n    let chunks = [];\n    let previousChunks = [];\n    const keyedChunks = new Map();\n    const toRemove = [];\n    /**\n     * This is the actual document partial function.\n     */\n    const partial = () => {\n        let dom;\n        if (!chunks.length)\n            addPlaceholderChunk();\n        if (chunks.length === 1 && !isTpl(chunks[0].tpl)) {\n            // In this case we have only a textNode to render, so we can just return\n            // the text node with the proper value applied.\n            const chunk = chunks[0];\n            chunk.dom.length\n                ? (chunk.dom[0].nodeValue = chunk.tpl)\n                : chunk.dom.push(document.createTextNode(chunk.tpl));\n            dom = chunk.dom[0];\n        }\n        else {\n            dom = assignDomChunks(fragment(createNodes(html), expressions)());\n        }\n        reset();\n        return dom;\n    };\n    partial.ch = () => previousChunks;\n    partial.l = 0;\n    partial.add = (tpl) => {\n        if (!tpl && tpl !== 0)\n            return partial;\n        // If the tpl is a string or a number it means the result should be a\n        // textNode — in that case we do *not* want to generate any DOM nodes for it\n        // so here we want to ensure that `html` is just ''.\n        let localExpressions = [];\n        let key;\n        let template = '';\n        if (isTpl(tpl)) {\n            ;\n            [template, localExpressions, key] = tpl._h();\n        }\n        html += template;\n        html += bookendComment;\n        const keyedChunk = key && keyedChunks.get(key);\n        const chunk = keyedChunk || {\n            html: template,\n            exp: localExpressions,\n            dom: [],\n            tpl,\n            key,\n        };\n        chunks.push(chunk);\n        if (key) {\n            // Since this is a keyed chunk, we need to either add it to the\n            // keyedChunks map, or we need to update the expressions in that chunk.\n            keyedChunk\n                ? keyedChunk.exp.forEach((exp, i) => exp._up(localExpressions[i].e))\n                : keyedChunks.set(key, chunk);\n        }\n        expressions.e.push(...localExpressions);\n        partial.l++;\n        return partial;\n    };\n    partial._up = () => {\n        const subPartial = createPartial(group);\n        let startChunking = 0;\n        let lastNode = previousChunks[0].dom[0];\n        // If this is an empty update, we need to \"placehold\" its spot in the dom\n        // with an empty placeholder chunk.\n        if (!chunks.length)\n            addPlaceholderChunk(document.createComment(''));\n        const closeSubPartial = () => {\n            if (!subPartial.l)\n                return;\n            const frag = subPartial();\n            const last = frag.lastChild;\n            lastNode[startChunking ? 'after' : 'before'](frag);\n            transferChunks(subPartial, chunks, startChunking);\n            lastNode = last;\n        };\n        chunks.forEach((chunk, index) => {\n            // There are a few things that can happen in here:\n            // 1. We match a key and output previously rendered nodes.\n            // 2. We use a previous rendered dom, and swap the expression.\n            // 3. The actual HTML chunk is changed/new so we need to remove the nodes.\n            // 4. We render totally new nodes using a partial.\n            const prev = previousChunks[index];\n            if (chunk.key && chunk.dom.length) {\n                closeSubPartial();\n                // This is a keyed dom chunk that has already been rendered.\n                if (!prev || prev.dom !== chunk.dom) {\n                    lastNode[index ? 'after' : 'before'](...chunk.dom);\n                }\n                lastNode = chunk.dom[chunk.dom.length - 1];\n                // Note: we don't need to update keyed chunks expressions here because\n                // it is done in partial.add as soon as a keyed chunk is added to the\n                // partial.\n            }\n            else if (prev && chunk.html === prev.html && !prev.key) {\n                // We can reuse the DOM node, and need to swap the expressions. First\n                // close out any partial chunks. Then \"upgrade\" the expressions.\n                closeSubPartial();\n                prev.exp.forEach((expression, i) => expression._up(chunk.exp[i].e));\n                // We always want to reference the root expressions as long as the\n                // chunks remain equivalent, so here we explicitly point the new chunk's\n                // expression set to the original chunk expression set — which was just\n                // updated with the new expression's \"values\".\n                chunk.exp = prev.exp;\n                chunk.dom = prev.dom;\n                lastNode = chunk.dom[chunk.dom.length - 1];\n                if (isTextNodeChunk(chunk) && lastNode instanceof Text) {\n                    lastNode.nodeValue = chunk.tpl;\n                }\n            }\n            else {\n                if (prev && chunk.html !== prev.html && !prev.key) {\n                    // The previous chunk in this position has changed its underlying html\n                    // this happens when someone is using non-reactive values in the\n                    // template. We need to remove the previous nodes.\n                    toRemove.push(...prev.dom);\n                }\n                // Ok, now we're building some new DOM up y'all, let the chunking begin!\n                if (!subPartial.l)\n                    startChunking = index;\n                subPartial.add(chunk.tpl);\n            }\n        });\n        closeSubPartial();\n        let node = lastNode === null || lastNode === void 0 ? void 0 : lastNode.nextSibling;\n        while (node && group in node) {\n            toRemove.push(node);\n            const next = node.nextSibling;\n            node = next;\n        }\n        removeNodes(toRemove);\n        reset();\n    };\n    // What follows are internal \"methods\" for each partial.\n    const reset = () => {\n        toRemove.length = 0;\n        html = '';\n        partial.l = 0;\n        expressions = { i: 0, e: [] };\n        previousChunks = [...chunks];\n        chunks = [];\n    };\n    const addPlaceholderChunk = (node) => {\n        html = '<!---->';\n        chunks.push({\n            html,\n            exp: [],\n            dom: node ? [node] : [],\n            tpl: t `${html}`,\n            key: 0,\n        });\n    };\n    /**\n     * Walks through the document fragment and assigns the nodes to the correct\n     * DOM chunk. Chunks of DOM are divided by the bookend comment.\n     * @param frag - A document fragment that has been created from a partial\n     * @returns\n     */\n    const assignDomChunks = (frag) => {\n        let chunkIndex = 0;\n        const toRemove = [];\n        frag.childNodes.forEach((node) => {\n            if (node.nodeType === 8 && node.data === bookend) {\n                chunkIndex++;\n                // Remove the comment\n                toRemove.push(node);\n                return;\n            }\n            Object.defineProperty(node, group, { value: group });\n            chunks[chunkIndex].dom.push(node);\n        });\n        toRemove.forEach((node) => node.remove());\n        return frag;\n    };\n    const transferChunks = (partialA, chunksB, chunkIndex) => {\n        partialA.ch().forEach((chunk, index) => {\n            chunksB[chunkIndex + index].dom = chunk.dom;\n        });\n    };\n    return partial;\n}\n/**\n * Checks if a given chunk is a textNode chunk.\n * @param chunk - A partial chunk\n * @returns\n */\nfunction isTextNodeChunk(chunk) {\n    return chunk.dom.length === 1 && !isTpl(chunk.tpl);\n}\n","import { t } from './html';\nimport { r, w } from './reactive';\n/**\n * html is an alias for t\n */\nexport const html = t;\n/**\n * reactive is an alias for r\n */\nexport const reactive = r;\n/**\n * watch is an alias for w\n */\nexport const watch = w;\nexport { t, r, w };\nexport { nextTick } from './common';\n// TODO: REMOVE THIS\nexport { measurements } from './common';\n"],"names":[],"mappings":"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"}